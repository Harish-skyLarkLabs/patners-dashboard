{"ast":null,"code":"import { createAsyncThunk } from '@reduxjs/toolkit';\nimport { bundles } from '../../utils/constants.ts';\n// Transform the static data to match the expected Product interface\nconst transformBundlesToProducts = () => {\n  return bundles.map(bundle => ({\n    id: bundle.id,\n    name: bundle.name,\n    description: bundle.description,\n    created_by: null,\n    sub_bundles: bundle.subBundles.map(subBundle => ({\n      id: subBundle.id,\n      name: subBundle.name,\n      bundle: bundle.id,\n      tires: subBundle.tiers.map(tier => ({\n        id: tier.id,\n        name: tier.name,\n        price: tier.price,\n        sub_bundle: subBundle.id,\n        features: tier.features\n      }))\n    }))\n  }));\n};\n\n// Mock categories data\nconst mockCategories = [{\n  id: 1,\n  name: \"Defense & Security\"\n}, {\n  id: 2,\n  name: \"Public Safety\"\n}, {\n  id: 3,\n  name: \"Critical Infrastructure\"\n}, {\n  id: 4,\n  name: \"Healthcare Security\"\n}];\nexport const fetchProducts = createAsyncThunk('products/fetchAll', async (_, thunkAPI) => {\n  try {\n    // Simulate API delay\n    await new Promise(resolve => setTimeout(resolve, 300));\n    const transformedProducts = transformBundlesToProducts();\n    return transformedProducts;\n  } catch (error) {\n    return thunkAPI.rejectWithValue({\n      error: error\n    });\n  }\n});\nexport const fetchProductById = createAsyncThunk('products/fetchById', async (productId, thunkAPI) => {\n  try {\n    // Simulate API delay\n    await new Promise(resolve => setTimeout(resolve, 200));\n    const transformedProducts = transformBundlesToProducts();\n    const product = transformedProducts.find(p => p.id === parseInt(productId));\n    if (product) {\n      return product;\n    } else {\n      return thunkAPI.rejectWithValue({\n        error: {\n          message: \"Product not found\"\n        }\n      });\n    }\n  } catch (error) {\n    return thunkAPI.rejectWithValue({\n      error: error\n    });\n  }\n});\n\n// Fetch product categories\nexport const fetchProductCategories = createAsyncThunk('products/fetchCategories', async (_, thunkAPI) => {\n  try {\n    // Simulate API delay\n    await new Promise(resolve => setTimeout(resolve, 200));\n    return mockCategories;\n  } catch (error) {\n    return thunkAPI.rejectWithValue({\n      error: error\n    });\n  }\n});","map":{"version":3,"names":["createAsyncThunk","bundles","transformBundlesToProducts","map","bundle","id","name","description","created_by","sub_bundles","subBundles","subBundle","tires","tiers","tier","price","sub_bundle","features","mockCategories","fetchProducts","_","thunkAPI","Promise","resolve","setTimeout","transformedProducts","error","rejectWithValue","fetchProductById","productId","product","find","p","parseInt","message","fetchProductCategories"],"sources":["/home/skylark/Desktop/PARTNERS-PROD/patners-dashboard/src/store/products/productThunk.ts"],"sourcesContent":["import { createAsyncThunk } from '@reduxjs/toolkit';\nimport { bundles } from '../../utils/constants.ts';\nimport { Product, Category } from './productsSlice.ts';\n\n// Transform the static data to match the expected Product interface\nconst transformBundlesToProducts = (): Product[] => {\n  return bundles.map(bundle => ({\n    id: bundle.id,\n    name: bundle.name,\n    description: bundle.description,\n    created_by: null,\n    sub_bundles: bundle.subBundles.map(subBundle => ({\n      id: subBundle.id,\n      name: subBundle.name,\n      bundle: bundle.id,\n      tires: subBundle.tiers.map(tier => ({\n        id: tier.id,\n        name: tier.name,\n        price: tier.price,\n        sub_bundle: subBundle.id,\n        features: tier.features\n      }))\n    }))\n  }));\n};\n\n// Mock categories data\nconst mockCategories: Category[] = [\n  { id: 1, name: \"Defense & Security\" },\n  { id: 2, name: \"Public Safety\" },\n  { id: 3, name: \"Critical Infrastructure\" },\n  { id: 4, name: \"Healthcare Security\" }\n];\n\nexport const fetchProducts = createAsyncThunk('products/fetchAll',async (_,  thunkAPI ) => {\n    try {\n      // Simulate API delay\n      await new Promise(resolve => setTimeout(resolve, 300));\n      \n      const transformedProducts = transformBundlesToProducts();\n      return transformedProducts;\n    } catch (error) {\n        return thunkAPI.rejectWithValue({ error: error });\n  }\n});\n\nexport const fetchProductById = createAsyncThunk('products/fetchById',async (productId: any,  thunkAPI ) => {\n    try {\n      // Simulate API delay\n      await new Promise(resolve => setTimeout(resolve, 200));\n      \n      const transformedProducts = transformBundlesToProducts();\n      const product = transformedProducts.find(p => p.id === parseInt(productId));\n      \n      if (product) {\n        return product;\n      } else {\n        return thunkAPI.rejectWithValue({ error: { message: \"Product not found\" } });\n      }\n    } catch (error) {\n        return thunkAPI.rejectWithValue({ error: error });\n    }\n  }\n);\n\n// Fetch product categories\nexport const fetchProductCategories = createAsyncThunk('products/fetchCategories',async (_,  thunkAPI ) => {\n    try {\n      // Simulate API delay\n      await new Promise(resolve => setTimeout(resolve, 200));\n      \n      return mockCategories;\n    } catch (error) {\n        return thunkAPI.rejectWithValue({ error: error });\n    }\n  }\n);\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}